name: CI/CD Pipeline to EC2 With Image Push

on:
  push:
    branches: [main]

jobs:
  # Job для Сборки и Пуша Образа
  build-and-push:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Log in to Docker Hub
        # Вход в ваш Docker Registry (например, Docker Hub)
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }} # Убедитесь, что это PAT, у которого есть права на запись!

      - name: Set up Docker Buildx
        # Необходим для некоторых функций сборки Docker
        uses: docker/setup-buildx-action@v3
        
      - name: Build and push portfolio-site Docker image
        # Этот экшен сам соберет образ из Dockerfile и запушит его в Docker Hub
        uses: docker/build-push-action@v5
        with:
          context: . # Указывает на текущую директорию как контекст сборки
          file: ./Dockerfile # Указывает на ваш Dockerfile
          push: true # Разрешает пуш образа
          tags: ${{ secrets.DOCKER_USERNAME }}/portfolio-site:latest # Имя образа и тег
          cache-from: type=gha # Для ускорения повторных сборок
          cache-to: type=gha,mode=max # Для ускорения повторных сборок

  # Job для Развертывания на EC2
  deploy-to-ec2:
    needs: build-and-push # Этот job будет запускаться только после успешного build-and-push
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Нужен для git pull на сервере, если вы не клонируете каждый раз

      # Шаг 1: Настройка SSH-агента для доступа к EC2
      - name: Set up SSH
        uses: webfactory/ssh-agent@v0.5.3
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}

      # Шаг 2: Основной скрипт деплоя на EC2 по SSH
      - name: Deploy to Server via SSH
        env:
          SSH_HOST: ${{ secrets.SSH_HOST }}
          SSH_USERNAME: ${{ secrets.SSH_USERNAME }}
          DOCKER_USER: ${{ secrets.DOCKER_USERNAME }}
          DOCKER_PASSWORD: ${{ secrets.DOCKER_PASSWORD }}
          REPO_REMOTE_URL: "https://github.com/${{ github.repository }}.git" # Автоматически формируем URL репозитория
          IMAGE_NAME: ${{ secrets.DOCKER_USERNAME }}/portfolio-site:latest # Полное имя образа
          
        run: |
          set -e # Выйти немедленно, если любая команда завершится неудачей

          echo "Connecting to ${{ env.SSH_USERNAME }}@${{ env.SSH_HOST }}"

          # Использование `ssh -T` для выполнения нескольких команд на удаленном сервере.
          # `StrictHostKeyChecking=no` следует использовать с осторожностью. В продакшене лучше заранее добавить fingerprint.
          ssh -o StrictHostKeyChecking=no ${{ env.SSH_USERNAME }}@${{ env.SSH_HOST }} << 'EOF_SSH_SCRIPT'
            set -e # Обязательно повторяем set -e внутри скрипта на сервере
            
            REPO_PATH="/opt/portfolio-site" # Путь, где Docker Compose проект на сервере
            
            echo "--- Выполнение скрипта деплоя на удаленном сервере ---"

            # --- Обновление или клонирование репозитория ---
            if [ -d "$REPO_PATH/.git" ]; then
              echo "Repository already exists, pulling latest changes..."
              cd "$REPO_PATH" || { echo "ERROR: Failed to change directory to $REPO_PATH"; exit 1; }
              git pull origin main || { echo "ERROR: Failed to pull latest configuration changes"; exit 1; }
            else
              echo "Repository not found at $REPO_PATH, cloning it..."
              # Создаем директорию, если она не существует
              mkdir -p "$REPO_PATH" 
              git clone "$REPO_REMOTE_URL" "$REPO_PATH" || { echo "ERROR: Failed to clone repository"; exit 1; }
              cd "$REPO_PATH" || { echo "ERROR: Failed to change directory to $REPO_PATH after clone"; exit 1; }
            fi

            # --- Очистка Docker ---
            echo "Performing Docker system cleanup..."
            docker system prune -af # clean all unused (containers, images, networks) forcefully
            docker volume prune -f  # clean all unused volumes forcefully

            # --- Вход в Docker Hub на EC2 (для pull приватных образов) ---
            echo "Logging into Docker Hub on EC2..."
            echo "${DOCKER_PASSWORD}" | docker login --username "${DOCKER_USER}" --password-stdin || { echo "ERROR: Failed to login to Docker Hub on EC2!"; exit 1; }

            # --- Docker Compose действия на EC2 ---
            echo "Stopping existing services..."
            # Используем `docker compose` (с пробелом) вместо `docker-compose` (с дефисом)
            # `--remove-orphans` удалит контейнеры, которых нет в текущем docker-compose.yml
            # `|| true` позволяет не прерывать скрипт, если контейнеров еще нет
            docker compose down --remove-orphans || true 

            echo "Pulling latest Docker image (${IMAGE_NAME})..."
            # Вместо `docker compose pull` явно тянем только наш образ Hugo/Nginx
            # Это гарантирует, что мы получим именно тот образ, который только что запушили
            docker pull "${IMAGE_NAME}" || { echo "ERROR: Failed to pull latest image from Docker Hub!"; exit 1; }

            echo "Starting services..."
            # `--force-recreate` принудительно пересоздаст контейнеры (нужно для нового образа)
            # `--build` здесь НЕ нужен, так как образ уже собран и спулен
            # `--remove-orphans` повторно на случай, если что-то появилось
            docker compose up -d --force-recreate --remove-orphans || { echo "ERROR: Failed to start Docker Compose services!"; exit 1; }
            
            echo "--- Docker Compose services started. Performing health check... ---"
            
            # --- БЛОК ТЕСТИРОВАНИЯ ---
            ATTEMPTS=20 # Количество попыток
            DELAY=5     # Задержка между попытками в секундах
            
            # Предполагаем, что Nginx на EC2 слушает на 80 порту хоста,
            # и этот порт доступен локально через 127.0.0.1
            TARGET_URL="http://127.0.0.1" 

            for i in $(seq 1 "$ATTEMPTS"); do
                HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" "$TARGET_URL" || echo "000") # curl может упасть
                
                echo "$(date '+%H:%M:%S') - Attempt $i/$ATTEMPTS: Received HTTP code $HTTP_CODE from $TARGET_URL"
                
                if [ "$HTTP_CODE" -eq 200 ]; then
                    echo "SUCCESS: Nginx is serving the site (HTTP 200 OK)."
                    break
                fi
                
                if [ "$i" -eq "$ATTEMPTS" ]; then
                    echo "ERROR: Nginx did not return 200 OK for $TARGET_URL after $ATTEMPTS attempts. Last HTTP code: $HTTP_CODE"
                    echo "Checking container status:"
                    docker ps -a
                    docker logs portfolio-site-portfolio-site-1 # Просмотрите логи вашего основного контейнера Nginx
                    exit 1
                fi
                
                echo "Retrying in $DELAY seconds..."
                sleep "$DELAY"
            done
            
            echo "--- Деплой на EC2 успешно завершен! ---"
          EOF_SSH_SCRIPT

    # --- Telegram-уведомления ---
      - name: Send Telegram Notification (Success)
        if: success()
        uses: appleboy/telegram-action@master
        with:
          to: ${{ secrets.TG_CHAT_ID }}
          token: ${{ secrets.TG_BOT_TOKEN }}
          format: markdown
          message: |
            ✅ *Деплой успешен!*
            *Репозиторий:* `${{ github.repository }}`
            *Ветка:* `${{ github.ref_name }}`
            *Коммит:* `${{ github.sha }}`
          
            [Перейти на сайт](http://${{ secrets.DOMAIN_NAME }})
            [Посмотреть логи](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }})
    
      - name: Send Telegram Notification (Failure)
        if: failure()
        uses: appleboy/telegram-action@master
        with:
          to: ${{ secrets.TG_CHAT_ID }}
          token: ${{ secrets.TG_BOT_TOKEN }}
          format: markdown
          message: |
            ❌ *Деплой провален!*
            *Репозиторий:* `${{ github.repository }}`
            *Ветка:* `${{ github.ref_name }}`
            *Коммит:* `${{ github.sha }}`
          
            [Посмотреть логи](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }})