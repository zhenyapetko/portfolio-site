name: CI/CD Pipeline to EC2 With Image Push

on:
  push:
    branches: [main]

jobs:
  # Job для Сборки и Пуша Образа
  build-and-push:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Log in to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        
      - name: Build and push portfolio-site Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile
          push: true
          tags: ${{ secrets.DOCKER_USERNAME }}/portfolio-site:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max

  # Job для Развертывания на EC2
  deploy-to-ec2:
    needs: build-and-push
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      # Шаг 1: Настройка SSH-агента для доступа к EC2
      - name: Set up SSH
        uses: webfactory/ssh-agent@v0.5.3
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}

      # Шаг 2: Основной скрипт деплоя на EC2 по SSH
      - name: Deploy to Server via SSH
        env:
          SSH_HOST: ${{ secrets.SSH_HOST }}
          SSH_USERNAME: ${{ secrets.SSH_USERNAME }}
          DOCKER_USER: ${{ secrets.DOCKER_USERNAME }}
          DOCKER_PASSWORD: ${{ secrets.DOCKER_PASSWORD }}
          REPO_REMOTE_URL: "https://github.com/${{ github.repository }}.git"
          IMAGE_NAME: ${{ secrets.DOCKER_USERNAME }}/portfolio-site:latest
          # --- НОВОЕ --- Определяем REPO_PATH здесь, как переменную GITHUB ACTIONS
          REPO_PATH: "/opt/portfolio-site" # <- Теперь это переменная GitHub Actions
          
        run: |
          set -e

          echo "Connecting to ${{ env.SSH_USERNAME }}@${{ env.SSH_HOST }}"

          # Использование `ssh -T` для выполнения нескольких команд на удаленном сервере.
          # `StrictHostKeyChecking=no` следует использовать с осторожностью. В продакшене лучше заранее добавить fingerprint.
          # ВАЖНО: Передаем переменные окружения явно в SSH-сессию.
          # Для REPO_PATH теперь используем env.REPO_PATH напрямую.
          ssh -o StrictHostKeyChecking=no ${{ env.SSH_USERNAME }}@${{ env.SSH_HOST }} "
            set -e 

            # Экспортируем переменные окружения для использования внутри удаленного скрипта
            export DOCKER_USER='${{ env.DOCKER_USER }}'
            export DOCKER_PASSWORD='${{ env.DOCKER_PASSWORD }}'
            export REPO_REMOTE_URL='${{ env.REPO_REMOTE_URL }}'
            export IMAGE_NAME='${{ env.IMAGE_NAME }}'
            export REPO_PATH='${{ env.REPO_PATH }}' # <--- Теперь экспортируем REPO_PATH как и другие

            echo \"--- Выполнение скрипта деплоя на удаленном сервере ---\"

            # --- Обновление или клонирование репозитория ---
            if [ -d \"\$REPO_PATH/.git\" ]; then
              echo \"Repository already exists at \$REPO_PATH, pulling latest changes...\"
              cd \"\$REPO_PATH\" || { echo \"ERROR: Failed to change directory to \$REPO_PATH\"; exit 1; }
              git pull origin main || { echo \"ERROR: Failed to pull latest configuration changes\"; exit 1; }
            else
              echo \"Repository not found at \$REPO_PATH, cloning it...\"
              mkdir -p \"\$REPO_PATH\" || { echo \"ERROR: Failed to create directory \$REPO_PATH\"; exit 1; }
              git clone \"\$REPO_REMOTE_URL\" \"\$REPO_PATH\" || { echo \"ERROR: Failed to clone repository\"; exit 1; }
              cd \"\$REPO_PATH\" || { echo \"ERROR: Failed to change directory to \$REPO_PATH after clone\"; exit 1; }
            fi

            # --- Очистка Docker ---
            echo \"Performing Docker system cleanup...\"
            docker system prune -af 
            docker volume prune -f 

            # --- Вход в Docker Hub на EC2 (для pull приватных образов) ---
            echo \"Logging into Docker Hub on EC2, username: \${DOCKER_USER}...\"
            echo \"\${DOCKER_PASSWORD}\" | docker login --username \"\${DOCKER_USER}\" --password-stdin || { echo \"ERROR: Failed to login to Docker Hub on EC2!\"; exit 1; }

            # --- Docker Compose действия на EC2 ---
            echo \"Stopping existing services...\"
            docker compose down --remove-orphans || true 

            echo \"Pulling latest Docker image (\${IMAGE_NAME})...\"
            docker pull \"\${IMAGE_NAME}\" || { echo \"ERROR: Failed to pull latest image from Docker Hub!\"; exit 1; }

            echo \"Starting services...\"
            docker compose up -d --force-recreate --remove-orphans || { echo \"ERROR: Failed to start Docker Compose services!\"; exit 1; }
            
            echo \"--- Docker Compose services started. Performing health check... ---\"
            
          # --- БЛОК ТЕСТИРОВАНИЯ ---
          echo "Running post-deployment health check..."
          
          ATTEMPTS=3 # Увеличим количество попыток на случай долгого запуска
          DELAY=3     # Задержка между попытками в секундах
          
          # Если сайт работает по HTTPS и Nginx перенаправляет,
          # то нужно проверять HTTPS
          TARGET_URL="https://${DOMAIN_NAME}" # Используем переменную DOMAIN_NAME
          
          echo "Checking health on $TARGET_URL"

          for i in $(seq 1 $ATTEMPTS); do
              # Используем curl с опцией -k для игнорирования ошибок SSL при самоподписанных сертификатах (если есть)
              # Или просто -L для следования редиректам
              # Добавим -sL для тишины и следования редиректам
              HTTP_CODE=$(curl -sL -o /dev/null -w "%{http_code}" "$TARGET_URL")
              echo "$(date +'%H:%M:%S') - Attempt $i/$ATTEMPTS: Received HTTP code $HTTP_CODE from $TARGET_URL"
              
              if [ "$HTTP_CODE" -eq 200 ] || [ "$HTTP_CODE" -eq 301 ] || [ "$HTTP_CODE" -eq 302 ]; then
                  echo "Test passed: Site is accessible (HTTP $HTTP_CODE OK)."
                  break
              fi
              
              echo "Retrying in $DELAY seconds..."
              sleep "$DELAY"
              
              if [ "$i" -eq "$ATTEMPTS" ]; then
                  echo "Error: Site did not return 2xx/3xx OK for $TARGET_URL after $ATTEMPTS attempts. Last HTTP code: $HTTP_CODE"
                  docker ps -a # Выведем статус всех контейнеров для отладки
                  exit 1
              fi
          done

            
            echo \"--- Деплой на EC2 успешно завершен! ---\"
          "

    # --- Telegram-уведомления ---
      - name: Send Telegram Notification (Success)
        if: success()
        uses: appleboy/telegram-action@master
        with:
          to: ${{ secrets.TG_CHAT_ID }}
          token: ${{ secrets.TG_BOT_TOKEN }}
          format: markdown
          message: |
            ✅ *Деплой успешен!*
            *Репозиторий:* `${{ github.repository }}`
            *Ветка:* `${{ github.ref_name }}`
            *Коммит:* `${{ github.sha }}`
          
            [Перейти на сайт](http://${{ secrets.DOMAIN_NAME }})
            [Посмотреть логи](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }})
    
      - name: Send Telegram Notification (Failure)
        if: failure()
        uses: appleboy/telegram-action@master
        with:
          to: ${{ secrets.TG_CHAT_ID }}
          token: ${{ secrets.TG_BOT_TOKEN }}
          format: markdown
          message: |
            ❌ *Деплой провален!*
            *Репозиторий:* `${{ github.repository }}`
            *Ветка:* `${{ github.ref_name }}`
            *Коммит:* `${{ github.sha }}`
          
            [Посмотреть логи](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }})